{"./":{"url":"./","title":"Introduction","keywords":"","body":"Example GitBook website using GitLab with Netlify. Netlify Configuration In order to build this site with Netlify, simply log in or register at https://app.netlify.com/, then select \"New site from Git\" from the top right. Select GitLab, authenticate if needed, and then select this project from the list. You will need to set the build command to gitbook build and set the publish directory to _book. Netlify will handle the rest. In the meantime, you can take advantage of all the great GitLab features like merge requests, issue tracking, epics, and everything else GitLab has to offer. Building locally To work locally with this project, you'll have to follow the steps below: Fork, clone or download this project Install GitBook npm install gitbook-cli -g Fetch GitBook's latest stable version gitbook fetch latest Preview your project: gitbook serve Add content Generate the website: gitbook build (optional) Push your changes to the master branch: git push Read more at GitBook's documentation. Did you fork this project? If you forked this project for your own use, please go to your project's Settings and remove the forking relationship, which won't be necessary unless you want to contribute back to the upstream project. Troubleshooting CSS is missing! That means two things: Either that you have wrongly set up the CSS URL in your templates, or your static generator has a configuration option that needs to be explicitly set in order to serve static assets under a relative URL. Forked from @virtuacreative "},"QA/week2QA.html":{"url":"QA/week2QA.html","title":"Week2","keywords":"","body":"Q: 同學問vscode debug的設定問題，還有scanf and printf 在vscode debug的終端視窗，會延遲或是根本無法使用的問題。 A: :::success 首先， 建議資料夾名稱不要用 中文，不要空格以免造成vscode 抓不到檔案 打開的 資料夾就是你產生 a.exe 或是 {檔名}.exe的資料夾 ::: 以下範例: 資料夾名稱: week3 目前只有 test.c 建立 launch.json Add configurarion->c/c++ gdb launch 修改黃色框成以下 :::success vscode json相關的變數可參考官方網站 https://code.visualstudio.com/docs/editor/variables-reference ::: >gcc -g test.c -o test.exe debug 過程會開啟另外一個終端機，在那個終端機裡 input and output vscode 中斷點就可以正常除錯了 如果你的執行檔是 a.exe 那設定檔就改成如下 > gcc -g test.c "},"QA/week3QA.html":{"url":"QA/week3QA.html","title":"Week3","keywords":"","body":"Q1: 環境安裝 step 1: 下載安裝 msys2, 安裝gcc, gdb, git, make step 2: 找到 gcc, gdb, git, make 執行檔所安裝的資料夾，將其路徑新增到 環境變數的 path裡 step 3: 下載安裝 vscode，可起終端機(terminal)，並設定預設終端機為 powershell Q2: 以下程式有問題 #include int main() { char a, b; scanf(\"%d%d\", &a, &b); printf(\"%d %d\\n\",a,b); } :::success bug 發生在 scanf(\"%d%d\", &a, &b) 的%d 改成 %hhd就可以(h=half, hh=1/4) char %c, %hhd int %d short %hd long %ld float %f double %lf string %s ::: #include int main() { char a, b; scanf(\"%hhd%hhd\", &a, &b); printf(\"%d %d\\n\",a,b); } "},"QA/week4QA.html":{"url":"QA/week4QA.html","title":"Week4","keywords":"","body":"Q1: 由檔案導入 測試資料 cos(x) 範例 cos.c #include #include int main() { double x,r; scanf(\"%lf\", &x); r = x * 3.14159/180; printf(\"x=%f, cos = %lf\\n\", x, cos(r)); } 測資一 1.txt 60 windows powershell windows cmd (命令提示列) msys2 任意一個終端機 測資二 (空的) 2.txt 因為沒有測資，x=0是程式裡預設 測資三 (一串) in.txt 60 120 30 100 只捉第一個，正常。因為程式 就scanf一次 (3)修改一下程式就可以全部測完一串 #include #include int main() { double x,r; while(scanf(\"%lf\", &x)!=EOF) { r = x * 3.14159/180; printf(\"x=%f, cos = %lf\\n\", x, cos(r)); } } 如何在 vscode debug (1-4)的狀況。 設定一下 launch.json就搞定 如果你的 printf 在vscode debug 終端印不出來，如下 理由是: printf 印到 stdout， 先存在緩衝區。最後程式結束印出 所以我們可以程式一開始，就把stdout的緩衝區設為空的(NULL) cos.c 修改如下: #include #include int main() { double x,r; setbuf(stdout, NULL); //以下 stdout,i.e. 螢幕，將沒有緩衝區，他就會一個char一個char印出來 while(scanf(\"%lf\", &x)!=EOF) { r = x * 3.14159/180; printf(\"x=%f, cos = %lf\\n\", x, cos(r)); } } :::success 以上操作設定，以後我們就能使用檔案大量測資，來除錯 或是執行 Online 上面的伺服器就是用這樣的方法來檢測你們的程式是否正確 可惜無法再Online 上面除錯。這是很大的缺點 ::: Q2: 檔案導入資料，鍵盤輸入的除錯環境並存 Q1: 如何在 workspace 底下的子資料夾除錯，i.e.,只要在 workspace 中存在一個 launch.json檔。 範例: 我有一個workspace loop(也就是資料夾 loop)， loop 裡面有 一些 .c檔，也有子資料夾 inputByKeyboard, inputByFile 很明顯的，inputByFile 裡的c檔我要用 in.txt導入當測試資料，inputByKeyboard 裡的c檔我要用keyboard自己輸入 所以我的除錯環境就必須要有兩個配置如下 launch.json \"configurations\": [ { \"name\": \"測資in.txt除錯\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${fileDirname}/${fileBasenameNoExtension}\", \"args\": [\" :::info . Line 2-28 是第一個 設定 測資in.txt除錯 . Line 30-56 是第二個 設定 鍵盤輸入除錯 注意 Line 6, 34: \"program\": \"${fileDirname}/${fileBasenameNoExtension}\" 表示若要除錯的檔為 divide.c，則執行檔是 divide.exe，而divide.exe會在divide.c所在資料夾。 Line 7: \"args\": [\" 表示執行加入參數 Line 35: \"args\":[] 表示沒有參數導入 Line 9, 37: \"cwd\": \"${fileDirname}\" 表示目前工作資料夾設為 要除錯的檔案所在資料夾 ::: $gcc -g divide.c -o divide.exe 然後選除錯方式。 如果 gcc -g ...你已經很熟悉了，只要增加以下的tasks.json 設定檔在 .vscode中，就可以不用每次都編譯，只要除錯就自動幫你先編譯 task.json { \"tasks\": [ { \"type\": \"cppbuild\", \"label\": \"產生執行檔\", \"command\": \"gcc.exe\", \"args\": [ \"-fdiagnostics-color=always\", \"-g\", \"${file}\", \"-o\", \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\" ], \"options\": { \"cwd\": \"${fileDirname}\" }, \"problemMatcher\": [ \"$gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true }, \"detail\": \"Task generated by Debugger.\" } ], \"version\": \"2.0.0\" } 這是工作設定檔，裡面可以有多個工作，以label來呼叫使用，我們可以在 launch.json檔裡呼叫任一個 task 如下:在除錯前先呼叫產生執行檔，launch.json 加入以下設定即可，我是加在 \"miDebuggerPath\": \"gdb\", \"preLaunchTask\": \"產生執行檔\", \"setupCommands\":[ ... 測資in.txt除錯 inputByFile/eof.c 不需要自行產生執行檔，只要在 eof.c 設中斷點(不涉就一路直行到結束)，選 測資in.txt除錯，執行即可 同樣的方法，除錯 inputByKeyboard/do-while.c 1.至此除錯環境應該就夠你用了。 2.當執行檔需要由很多個.c檔產生，這時方塊(function)就會很多，初期除錯不會用gdb，而是先使用printf找出錯誤的方塊，那時再教你們，如何用printf 印出是哪一個function的信息。 由第2方法找出可能有錯的方塊，在利用gdb設定中斷來解決 例如: taskTimeOut: 是一個方塊 那裡印出 \"task0 tasktimeout\" workspace 如下: 這麼多 .c檔，每個.c裡面還有很多方塊(functions) 其中: taskTimeOut 方塊在 task.c裡。 "},"introduction/hello.html":{"url":"introduction/hello.html","title":"小程式","keywords":"","body":"小程式產生的過程 C 程式在執行前經過六個階段 :::success 1. 編輯：使用者可利用文書編輯器 (editor) 撰寫或修改 C 程式碼 (source code)- 例如: vscode, notepad++. 2. 前置處理：前置處理器 (preprocessor) 會在開始編譯前自動執行，依據程式碼中 # 所標 示的指示 (preprocessor directives)，進行代換或插入等動作。例如：#include 告 訴編譯器在未編譯程式之前，先將程式庫中的標頭檔 stdio.h 插入該位置。 3. 編譯：編譯器 (compiler) 將程式碼編譯為目的碼 (object code)。GNU gcc 產生 *.o檔 4. 連結：連結器 (linker) 將一個或多個目的檔 (.obj, .o) 與靜態程式庫檔 (.lib, .a) 連結，產生可 執行檔 (.exe)。 5. 載入：載入器 (loader) 將可執行檔 (.exe) 載入記憶體，並與動態程式庫檔 (.dll, .so) 連結。 動態程式庫可減少執行檔所佔的硬碟和記憶體空間。 6. 執行：最後，電腦在 CPU 的控制下，開始執行所載入的程式。 ::: Q1 :::info Editor preprocessor compiler linker loader 程式庫 誰負責寫的。用什麼語言寫的? 1-5 的程式叫做系統程式 2-4 的程式就是我們常說的 toolchain (工具鍊)(在開發不一樣的CPU下執行的程式，需要不一樣的工具鍊)-例如: 開發手機執行的程式，與開發在PC上執行的程式，使用不一樣的工具鍊) ::: 小結論 :::warning 一個小程式至少會有一個 主程式檔 .c 很多時候也會有一個 .h檔 (標頭檔) Q2 那些東西放在 .c, 那些該放在 .h ? ::: 用 C 語言寫出一個 Hello, World! 剛開始學習一個程式語言，我們都會先試著在螢幕上輸出 Hello, World! 這串字， #include int main(void) { printf(\"Hello, World!\\n\"); return 0; } 接著就是解釋這段程式碼 :::success 一般程式的開頭用來引用標頭檔 例如第一行是用來引用標頭檔，告訴編譯器我們需要用 stdio.h 這個標頭檔。標頭檔裡面記載了不同的函式(function，可以暫時把函式當作指令)的用法，一旦你用了某個函式，你就必須加入那個函式的標頭檔，例如這個程式碼會引用 stdio.h 就是因為用了 printf 這個函式。 #include 再來是主程式 main 的部分。main 為程式的進入點，也就是說一支程式在執行時會先找 main 開始執行。而小括號裡面的 void 代表這個函式沒有傳入值，不需要傳參數進去 ```C int main(void){ } 3. **printf** 是 print 和 formatted 的縮寫，可以把東西以特定格式輸出到螢幕上。其中的 \\n 是換行的意思。 ```c printf(\"Hello, World!\\n\"); 最後以 return 來結束程式，一般來說程式如果正常結束會回傳 0。return 0; 在第一篇文章中，對 Hello, World! 有這樣的認識就足夠了。至於標頭檔在做什麼？函式該怎麼用？\\n為什麼代表換行？有沒有其他的可以用？這些問題在後面的章節會再仔細講解。 ::: 大括號該怎麼放？大括號一定是倆倆對應的！ 縮排很重要，請統一使用 TAB 鍵或四個空格 有縮排的看起來是這樣 ```C= include int main(void) { printf(\"Hello, World!\\n\"); return 0; } >沒縮排的話看起來像這樣： ```C= #include int main(void) { printf(\"Hello, World!\\n\"); return 0; } Hello World! 開發過程 1. 使用 編輯器(vscode) 編輯 檔案名稱存為 hello.c，本範例只有一個檔案 hello.c需要自己寫。 stdio.h是系統提供(已經存在)，我們只要include就可以。 2. 前置處理，利用 gcc完成所有 .c檔內的引入標頭檔的引入。 gcc --help 可以列出gcc所有選項，其中 -E 就是有關前處理相關 $gcc --help|more 以下指令會產生 hello.i 完成前處理的hello.c內容檔 $gcc -E hello.c > hello.i :::success 開啟hello.i 可看出檔案變成 961行，其中 958-961 就是我們寫的程式，以上的就是 stdio.h 檔被貼在原來 #include 這裡 ::: 如果我把 hello.c 改成如下 int main(void) { printf(\"Hello, World!\\n\"); } #include 再看看前處理後內容會變成如下 $gcc -E hello.c hello.i1 stdio.h 內容就被貼在我們寫的程式底下，由此可知， #include 寫在哪裡，stdio.h內容就會被貼在哪裡。 3. 編譯程式(compile) 將我們寫的每一個 .c 檔，一個檔案一個檔案的編譯成目的檔，(.obj, .o) Hello World! 程式只有一個 hello.c檔，所以只產生一個 目的檔hello.o $gcc -c hello.c 如果你的程式需要寫不只一個 .c 檔，那必須每個 .c 檔都要編譯出 相對應的 .o 檔，例如下面這個專案，寫了 5 個 .c檔，所以要製作執行檔過程就會編譯出 5個相對應的 .o檔 這個過程就叫 編譯(compile)，當然也是使用工具鏈中的 gcc完成 4. 鏈結所有相關的 目的檔(.o)成一個可執行的檔案 Hello World! 程式只有一個目的檔 hello.o，同時程式中使用了printf這個函數，這個函數是系統提供的標準輸出輸入函數庫(library)，所以不需要特別參數就可找到，所以產生 Hello World執行檔，操作如下 產生預設的執行檔案 a.exe $gcc hello.o 也可產生自訂的執行檔案 hello.exe $gcc hello.o -c hello.exe 由圖中可看出， a.exe, hello.exe 是一樣的結果。 :::success 如果我們的程式需要多個目的檔(.o)才能鏈結成一個執行檔，那以下方法是一個例子。 其中這個例子會產生執行檔 shell.exe，因為.c檔中有用到某個函數，而這個函數在readline library內，所以連結時需要告知，用參數 -lreadline告知 gcc 去readline library去找。 ::: $gcc ui.o main.o parse.o buildin.o exec.o -o shell.exe -lreadline :::danger NOTE: 期中考前，我們學習的是第一階段，熟悉語言，不太用到多個程式的專案。 期中考後，才會學習到寫程式來解決問題，就很大的機會需要寫不只一個.c檔的專案。 ::: 到此，就是開發一個程式所有過程 其實以上過程只需要做這一次就可以了，因為gcc會幫我們完成1-4的工作，所以Hello World!!程式的產生，只要以下的一個指令，gcc就會幫我們走完上面的過程，當然如果程式有問題，中途就會跳出，並且告訴我們問題。我們再修改掉問題，重複以下動作就可以 # 產生 hello.exe $gcc hello.c -o hello.exe # or # 產生 a.exe $gcc hello.c :::warning 身為資工的背景，這過程還是需要了解的，不要當一個只會按滑鼠的電腦使用者，要能融會貫通的 電腦設計開發者。 ::: :::info 當然過程中，會出現程式寫錯需要除錯的時候，到那時我再教，如何有效率的利用工具鏈除錯。 ::: "},"introduction/git.html":{"url":"introduction/git.html","title":"雲端碼庫","keywords":"","body":"原始碼程式版本控制 git 使用 可自行參考 網路上教學 寫給 Git 初學者的入門 4 步驟 建立新的專案目錄 :::success 以下說明建構 2023programming 資料夾，此資料夾將存放所有上課相關的原始碼, 例如 00hello等。 ::: 建立2023programming 資料夾 $mkdir 2023programming 進入2023programming 資料夾 $cd 2023programming 1. 建立本地資料庫 .git 目錄 $git init 建立2023programming/00hello 資料夾 $mkdir 00hello 當我們完成一個階段的工作，會將整個專案的檔案上傳到git雲端，用以備份管控專案的版本。 將檔案移入索引中 2. 基本步驟為 git add * 將索引內的檔案提交至本地數據庫 git commit -n -m \"備註這次修改的文字\" 因為此例為新創建，所以需要設定 user.name, user.email 資料，如箭頭 3. 新增hello.c 接下來我們用vscode打開2023programming 資料夾，並在 00hello目錄裡，新增一檔案 hello.c 輸入C程式，原始碼如下: ```C=1 include int main() { printf(\"Hello World!!\\n\"); } ```bash $git add * $git commit -n -m \"00hello\" 很清楚看見， hello.c被記錄到 .git 目錄中，目前版本是 master 免費雲端儲存庫使用 - gitee.com 為例 第一次上傳到git雲端 step1 $git remote add origin https://github.com/chtsai0256/2023programming.git step2 $git push --set-upstream origin master 雲端已經存在的專案 複製 git clone $ git clone https://gitee.com/dclab-ndhu/2023programming.git 拉下來修改 git pull 此情況，是在你的電腦裡已經有此專案，利用git pull 更新版本 修改專案，最後push上雲端 $git add * $git commit -m \"註記\" $git push 有些檔案不想上傳，例如:a.exe 參考 https://gitbook.tw/chapters/using-git/ignore 修改 .gitignore 檔案 hello.tmp, a.exe 沒有push到雲端 "},"introduction/debug.html":{"url":"introduction/debug.html","title":"除錯","keywords":"","body":"程式錯誤的種類 程式語法或程式文法錯誤 :::success 一般編輯器有支援 C語法的，在編輯時就會出現警示，如底線 再來編譯時會出現錯誤的行號 如上例出現 5, 6那二行有問題，\";\" 基本上這是比較低級的錯誤，因為根本不會編譯過，所以根本在執行不會發生。第一次學程式的同學，必須要盡快能自行處理這種錯誤。 ::: 執行的結果錯誤 執行結果錯誤，一般出現在 程式的邏輯錯誤，或是解題的方法錯誤，一般同學會用 printf 來階段性的印出部分結果看看是法有誤。 當發現那一塊程式有問題，就會利用GDB設定中斷點來一步一步執行，找出錯誤的地方。 segmentation fault :::success 這種錯誤，是可以編譯但執行時會出現 exception(例外)，然後程式就停止執行。 exception: 這是一種中斷機制，CPU發出的，exception有很多種類，程式發生的較常見的是 記憶體存取違背權限(也就是存取到不能動的區域)，通常是記憶體處理不當。這個機制的學習會在大二的硬體設計課程中出現，也會在大二以上用到資料結構的課程程式裡發生。 ::: 同一個程式在 windows 的開發環境出現的錯誤提示如上，與linux不同，但都是 exception. linux 系統中出現的是 segmentation fault(core dump) :::success segmentation fault 的錯誤只有在執行時會出現，所以除錯的方法，我們都用 gdb 來除錯，利用中斷點一步一步的執行，找出錯誤。 ::: 如何在 vscode中使用其介面來除錯 這裡講的就是以上介紹重中之重的，能設定中斷點，能一步一步執行，能看變數的變化，能看記憶體內容的除錯方法。這方法就是用 GDB來除錯 以下是我們使用的例子 :::success 寫一個程式計算 sum = 1+2+3+...+10，並印出結果 ::: 我們將要解這個問題的所有檔案都放在同一個資料夾 sum 中，這個例子很簡單，資料夾中只需要一個.c檔，就命名為 sum.c吧, 最後結果執行檔也叫sum.exe吧 sum.c 如下 ```C=include //因為要用到standard I/O 中寫好的函數 printf列印結果 int main(){ int i,sum; sum=0; for(i=1;i} ![](https://hackmd.io/_uploads/BywPF-jR3.png) :::success ```bash! $ gcc -g sum.c -o sum.exe -g 會產生debug需要的相關資料在 sum.exe中 -o 產生 sum.exe ::: 以上而2個 sum.exe，執行結果都一樣，但第一個用 -g 含有除錯用資訊，所以檔案大小比第二個sum.exe大 除錯 sum.exe step 1: 產生含有除錯資訊的執行檔 $ gcc -g sum.c -o sum.exe step 2: 利用 gdb 除錯 修改以下框起來的部分 :::success 完成設定後，sum 資料夾中就會出現 .vscode的資料夾，以及 launch.json設定檔。 就可以開始操作除錯 ::: 開始 debug sum.exe 假設我想看看 sum.c 的 sum=0 可使的運行 我就在 sum=0這裡點為中斷點 按下 開始除錯，程式會停在第一個中斷點(中斷點可以點很多個)，等著你下指令 指令 可自行試試 也可以在 variable區塊看見區域變數的變化 也可以在 watch區塊中加入你像看得運算 以下是執行到第二個中斷點 printf 可看見，所有區域變數 i, sum 此刻的值，還有加入觀察的運算式 sum+100的值。 :::success 如過程式運算過程觀測的值，跟我們預想的不一樣，那就是 bug，錯誤就發現了，這樣只要專注在錯誤的地方修改，修改後再同樣的方法除錯，一直到程式正確。 ::: 除錯的過程就是寫程式修行過程，不要省略 當你的程式有問題時，就把GDB搞起來，時間久了保證你的功夫就練成了 尤其在使用指標，跟管理記憶體位址時，GDB會是你的好工具，也是你程式進階的好老師 "},"IF/IF.html":{"url":"IF/IF.html","title":"判斷","keywords":"","body":":::success 以下範例程式在 https://gitee.com/dclab-ndhu/2023programming.git 的branch 資料夾內 可以直接 git clone 下來 資料夾內 slide.pdf 是投影片檔 ::: if if then if-then.c ```clike=include int main() { int i; scanf(\"%d\", &i); if (i > 0) printf(\"%d\\n\", i); } 2. product-positive.c ```clike= #include int main() { int i, j; scanf(\"%d%d\", &i, &j); if (i * j > 0) { printf(\"%d\\n\", i); printf(\"%d\\n\", j); } } if then else abs.c ```clike=include int main() { int i, k; scanf(\"%d\", &i); if (i > 0) k = i; else k = -i; printf(\"%d\\n\", k); } **變形寫法** - cond-abs.c ```clike= #include int main() { int i, k; scanf(\"%d\", &i); k = (i > 0)? i: -i; printf(\"%d\\n\", k); } max-3.c #include main() { int i, j, k, max; scanf(\"%d%d%d\", &i, &j, &k); if (i > j) max = i; else max = j; if (k > max) max = k; printf(\"%d\\n\", max); } 變形寫法 cond-max-3.c #include int main() { int i, j, k; scanf(\"%d%d%d\", &i, &j, &k); int max = (i > j)? i : j; if (k > max) max = k; printf(\"%d\\n\", max); } area-branch.c #include int main() { int a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d); int width, height; if (c > a) width = c - a; else width = a - c; if (d > b) height = d - b; else height = b - d; int area = width * height; int perriphral = 2 * (width + height); printf(\"%d\\n\", area); printf(\"%d\\n\", perriphral); } 變形一下更簡潔 area-cond.c ```clike=include int main() { int a, b, c, d; scanf(\"%d%d%d%d\", &a, &b, &c, &d); int width = (c > a)? c - a : a - c; int height = (d > b)? d - b : b - d; int area = width height; int perriphral = 2 (width + height); printf(\"%d\\n\", area); printf(\"%d\\n\", perriphral); } 4. sort-print.c ```clike= #include int main() { int i, j; scanf(\"%d%d\", &i, &j); if (i > j) { printf(\"%d\\n\", j); printf(\"%d\\n\", i); } else { printf(\"%d\\n\", i); printf(\"%d\\n\", j); } } if then else if leap-year-else-if.c ```clike=include include int main() { int year; scanf(\"%d\", &year); bool leapYear; if (year % 400 == 0) leapYear = true; else if ((year % 4 == 0) && (year % 100 != 0)) leapYear = true; else leapYear = false; printf(\"%d\\n\", leapYear); } :::danger **變數命名法** ::: **變形寫法** - cond-leap-year.c ```clike= #include #include int main() { int year; scanf(\"%d\", &year); bool leapYear = (year % 400 == 0)? 1 : ((year % 4 == 0) && (year % 100 != 0)) ? 1 : 0; printf(\"%d\\n\", leapYear); } switch 也許更好 switch-power.c#include int main() { int base, power, exponent; scanf(\"%d%d\", &exponent, &base); switch (exponent) { case 1: power = base; break; case 2: power = base * base; break; case 3: power = base * base * base; break; default: power = 0; } printf(\"%d\\n\", power); } break小心用 switch-power-no-break.c#include int main() { int base, power, exponent; scanf(\"%d%d\", &exponent, &base); switch (exponent) { case 1: power = base; break; case 2: power = base * base; /* no break here */ case 3: power = base * base * base; break; default: power = 0; } printf(\"%d\\n\", power); } break用對了程式也許更簡潔 month.c ```clike=include int main() { int year, month, days; scanf(\"%d%d\", &year, &month); switch (month) { case 1: case 3: case 5: case 7: case 8: case 10: case 12: days = 31; break; case 4: case 6: case 9: case 11: days = 30; break; case 2: if ((year % 400 == 0) || (year % 4 == 0 && (year % 100 != 0)))days = 29; elsedays = 28; break; default: days = 0; } printf(\"%d\\n\", days); } **應用一下switch** - calc-switch.c ```clike= #include int main() { int a, b, c, d; scanf(\"%d%d%d\", &a, &b, &c); switch (c) { case 0: d = a + b; break; case 1: d = a - b; break; case 2: d = a * b; break; case 3: d = a / b; break; case 4: d = a % b; break; default: printf(\"invalid c %d\\n\", c); d = 0; } printf(\"%d\\n\", d); } 利用 define 讓程式更容易讀懂 calc-switch-define.c #include #define ADD 0 #define SUB 1 #define MUL 2 #define DIV 3 #define MOD 4 main() { int a, b, c, d; scanf(\"%d%d%d\", &a, &b, &c); switch (c) { case ADD: d = a + b; break; case SUB: d = a - b; break; case MUL: d = a * b; break; case DIV: d = a / b; break; case MOD: d = a % b; break; default: printf(\"invalid c %d\\n\", c); d = 0; } printf(\"%d\\n\", d); } compare-switch.c ```clike= include include define EQL 5 define NOTEQL 6 define SMALLER 7 define LARGER 8 define SMALLEREQL 9 define LARGEREQL 10 int main() { int a, b, c; scanf(\"%d%d%d\", &a, &b, &c); bool d; switch (c) { case EQL: d = (a == b); break; case NOTEQL: d = (a != b); break; case SMALLER: d = (a b); break; case SMALLEREQL: d = (a = b); break; default: printf(\"invalid c %d\\n\", c); d = false; } printf(\"%d\\n\", d); } ``` "},"LOOP/LOOP.html":{"url":"LOOP/LOOP.html","title":"迴圈","keywords":"","body":" 以下範例程式在 https://gitee.com/dclab-ndhu/2023programming.git 的 loop 資料夾內 可以直接 git clone 下來 資料夾內 slide.pdf 是投影片檔 或直接連結 https://gitee.com/dclab-ndhu/2023programming/tree/master/loop ‌import * as React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; ReactDOM.render(, window.document.getElementById('root')); while loop not-less-than.c #include int main() { int j; scanf(\"%d\", &j); int i = 0; while (i sum.c #include int main() { int k; scanf(\"%d\", &k); int i = 1, sum = 0; while (i gcd(i,j) gcd.c #include int main() { int i, j, k; scanf(\"%d%d\", &i, &j); while (i % j != 0) { k = i % j; i = j; j = k; } printf(\"%d\\n\", j); } check EOF eof.c #include int main() { int i; while (scanf(\"%d\", &i) != EOF) printf(\"%d\\n\", i); } for loop for-print.c #include int main() { int j; scanf(\"%d\", &j); for (int i = 0; i prime.c #include #include int main() { int n; scanf(\"%d\", &n); bool prime = true; for (int i = 2; (i * i) sum-square-cubic.c #include int main() { int n; scanf(\"%d\", &n); int sum = 0; int square_sum = 0; int cubic_sum = 0; for (int i = 1; i do while loop do-while.c #include main() { int i; scanf(\"%d\", &i); do i++; while (i sum-square-cubic-do-while.c #include main() { int n; scanf(\"%d\", &n); int i = 1; int sum = 0; int square_sum = 0; int cubic_sum = 0; do { sum += i; square_sum += (i * i); cubic_sum += (i * i * i); i++; } while (i break 的使用 prime-break.c #include #include int main() { int n; scanf(\"%d\", &n); bool prime = true; for (int i = 2; (i * i) prime-flag.c #include #include int main() { int n; scanf(\"%d\", &n); bool prime = true; for (int i = 2; ((i * i) continue的使用 continue.c #include main() { int n; scanf(\"%d\", &n); int sum = 0; for (int count = 0; count no-continue.c #include main() { int n; scanf(\"%d\", &n); int sum = 0; for (int count = 0; count 0) { sum += i; } } printf(\"%d\\n\", sum); } 多重迴圈 nine.c #include main() { for (int i = 1; i 回家寫一個這樣的九九乘法表 Loop 範例 長除法 (divide.c) :::success 給 n, k, 求n/k? n可能很大，大到64位元都無法表示 為了簡化計算，假設 1 n可以很長，可能無法用 64位元表示 因為我們還沒學到 陣列型態，所以輸入限制每次輸入一個0-9的數字例如: 234678910678 這個數的輸入如下: 2 3 4 6 ... 8 輸出的結果也有這個狀況 ::: 算法 #include int main() { int k; scanf(\"%d\", &k); int count = 0, prev = 0; int toPrint; int digit; while (scanf(\"%d\", &digit) != EOF) { int value = 10 * prev + digit; toPrint = value / k; if (!(count == 0 && toPrint == 0)) printf(\"%d\\n\", toPrint); prev = value % k; count++; } if (count == 1 && toPrint == 0) printf(\"0\\n\"); } :::success 例如: k=7, n = 3848 input 如下 7 3 8 4 8 結果: n/k = 3848/7 = 549 輸出: 5 4 9 ::: 檢查 11的倍數 (eleven.c) :::success 輸入一長整數，檢查是否為11的倍數 這個整數可以很長，可能無法用 64位元表示 因為我們還沒學到 陣列型態，所以輸入限制每次輸入一個0-9的數字例如: 234678910678 這個數的輸入如下: 2 3 4 6 ... 8 ::: 算法 #include int main() { int digit; int count = 0; int evenSum = 0, oddSum = 0; while (scanf(\"%d\", &digit) != EOF) { if (count % 2 == 0) evenSum += digit; else oddSum += digit; count++; } int diff = evenSum - oddSum; if (diff "},"array/Array.html":{"url":"array/Array.html","title":"陣列","keywords":"","body":"[TOC] Array (陣列) 以下範例程式在 https://gitee.com/dclab-ndhu/2023programming.git 的 array 資料夾內 可以直接 git clone 下來 資料夾內 slide.pdf 是投影片檔 或直接連結 https://gitee.com/dclab-ndhu/2023programming/tree/master/array 一維陣列 print-array.c #include #define ARRAYSIZE 10 main() { int a[ARRAYSIZE]; for (int i = 0; i inner-product.c (計算內積) #include #define ARRAYSIZE 5 main() { int A[ARRAYSIZE], B[ARRAYSIZE]; for (int i = 0; i fib-array.c (計算 費博內希數列到第n項) #include #include #define FIBARRAYSIZE 100 main() { int n; scanf(\"%d\", &n); assert(n >= 2 && n prime-array.c (印出n之內的質數) #include #include #include #define ARRAYSIZE 101 main() { int n; scanf(\"%d\", &n); assert(n >= 2 && n bubble-sort.c 泡沫排序法 #include #include #define ARRAYSIZE 100 main() { int m; scanf(\"%d\", &m); assert(m >= 1 && m = 0; i--) for (int j = 0; j n[j + 1]) { int temp = n[j]; n[j] = n[j + 1]; n[j + 1] = temp; } for (int i = 0; i print-array-address.c 印出陣列a中的元素大小及在記憶體中的位址。 #include #define ARRAYSIZE 10 main() { int a[ARRAYSIZE]; printf(\"%ld\\n\", sizeof(a[0])); printf(\"%ld\\n\", sizeof(a)); for (int i = 0; i print-array-address-exp.c #include #define ARRAYSIZE 10 main() { int a[ARRAYSIZE]; printf(\"&a is %p\\n\", &a); printf(\"a is %p\\n\", a); printf(\"&(a[0]) is %p\\n\", &(a[0])); printf(\"a + 3 is %p\\n\", a + 3); printf(\"&(a[3]) is %p\\n\", &(a[3])); } match.c 在陣列中找一特定值 #include #include main() { int keys[] = {3, 4, 6, 2, 8, 10}; int arraySize = sizeof(keys) / sizeof(int); int key; scanf(\"%d\", &key); bool found = false; for (int i = 0; i 多維陣列 matrix-multiply.c 矩陣相乘 #include #define ROWA 2 #define COLA 3 #define ROWB COLA #define COLB 4 #define ROWC ROWA #define COLC COLB main() { int A[ROWA][COLA], B[ROWB][COLB], C[ROWC][COLC]; for (int i = 0; i matrix-multiply-lines.c 將上面的印出以矩陣的樣子印出 #include #define ROWA 2 #define COLA 3 #define ROWB COLA #define COLB 4 #define ROWC ROWA #define COLC COLB main() { int A[ROWA][COLA], B[ROWB][COLB], C[ROWC][COLC]; for (int i = 0; i for-print-one-line.c 在for迴圈中印出i的值成一行 #include #include main() { int start, end; scanf(\"%d%d\", &start, &end); assert(start prime-array-line.c 印出100之內的質數，每8個一行 #include #include #define ARRAYSIZE 1000 main() { int n, column; scanf(\"%d%d\", &n, &column); assert(n 0); int composite[ARRAYSIZE]; for (int i = 2; i circle.c 繞圈 #include main() { int n; scanf(\"%d\", &n); int array[n][n]; for (int r = 0; r life.c 生命遊戲 #include #include #include #define MAXSIZE 100 int main() { int n, k; setbuf(stdout,NULL); scanf(\"%d%d\",&n, &k); assert(n>=1 &&n0); int current=0, next=1; bool life[2][MAXSIZE][MAXSIZE]; //input array for (int i=0; i=0 && x=0 && y life-func.c 生命遊戲函數版 #include #include #include #define MAXSIZE 100 //#define DEBUG bool life[2][MAXSIZE][MAXSIZE]; void inputArray(int n) { for (int i=0; i=0 && x=0 && y=1 &&n0); int current=0, next=1; inputArray(n); #ifdef DEBUG printArray(n, 0); #endif for (int iter=0; iter mirror.c 鏡子房間 #include #include main() { int W, D; scanf(\"%d%d\", &W, &D); bool mirror[W][D]; for (int d = D - 1; d >= 0; d--) for (int w = 0; w = 0 && x = 0 && y = W) printf(\"%d\\n\", W + y); else if (y >= D) printf(\"%d\\n\", W + D + (W - x) - 1); else printf(\"%d\\n\", 2 * W + D + (D - y) - 1); } } magic.c 印出nxn奇魔方陣，其中n是奇數 #include #include #include #define N 100 int main(void) { int matrix[N][N] = {0}; int size; scanf(\"%d\", &size); assert(size%2==0 && size>100); int i = 0; int j = (size+1) / 2; int key; for(key = 1; key size) j = 1; matrix[i - 1][j - 1] = key; } int m, n; for(m = 0; m magic_inTxt.c 魔方測資版 #include #include #include #define N 10 int main(void) { int matrix[N][N] = {0}; int size; while(scanf(\"%d\", &size)!=EOF) { assert(size%2!=0 && size size) j = 1; matrix[i - 1][j - 1] = key; } int m, n; for(m = 0; m "}}